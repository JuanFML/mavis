SVMerge User Manual
====================

About
--------------------

pipeline to merge and validate input from different structural variant callers into a single report

Getting started
--------------------

Installing the tool
....................

the tool has multiple dependencies from svn. These are listed in the install.sh bash script which also builds the autogenerated documentation. It should be run from the directory it is in

.. code-block:: bash

    cd /path/to/svmerge/dir
    pip install -r requirements.txt
    bash install.sh


Running Unit Tests
....................

to run the tests

.. code-block:: bash

    cd /path/to/svmerge/dir
    nosetests --with-coverage --cover-html --cover-html-dir=coverage --cover-package=structural_variant --cover-package=tools --cover-erase

Input Files
....................

The requirements are described in [JIRA](https://www.bcgsc.ca/jira/browse/APA-618) and are listed below.
These pertain to the input files from the various tools you want to merge

::

    | column name       | description                                                                       |
    |-------------------|-----------------------------------------------------------------------------------|
    | start_position    | range for the first breakpoint position                                           |
    | start_strand      | the reference strand aligned to                                                   |
    | start_orientation | the orientation (L or R) retained at the first breakpoint wrt the positive strand |
    | end_chromosome    |                                                                                   |
    | end_position      | range for the second breakpoint position                                          |
    | end_strand        | the reference strand aligned to                                                   |
    | end_orientation   | the orientation (L or R) retained at the second breakpoint wrt the positive strand|
    | protocol          | genome or transcriptome                                                           |
    | library           |                                                                                   |
    | tool_version      | tool name and tool version number joined with an underscore, no spaces            |
    | opposing_strand   | boolean value to describe if the breakpoints are on opposing strands              |
    | stranded          | boolean, if True then read1 in read pairs is assume to be the proper strand       |

Available Pre-formatting scripts
.................................

- Trans-ABySS
    - [convert_ta.py](https://svn.bcgsc.ca/svn/SVIA/sv_compile/tags/<version>/tools/convert_ta.py)
- DELLY
    - DUSTIN TO ADD
- MANTA
    - CALEB TO ADD

Building the documentation
...........................

if you don't use the install script there is also a wrapper script provided for generating the documentation

.. code-block:: bash

    cd /path/to/svmerge/dir/docs
    bash create.sh

this will generate html documentation that can be viewed in a browser by opening the index.html file

How it works
--------------------

The main pipeline consists of 3 scripts: sv_merge.py, sv_validate.py, and sv_annotate.py

sv_merge.py
....................

- takes in the calls from various tools and splits them by protocol and library
- clusters breakpoints by distance (user-configurable)

sv_validate.py
....................

- takes in the breakpoint calls
- sets a window around the breakpoints, based on user-configurable settings, for where to gather reads from the bam file. For genomic breakpoints this is a simple function of the read length, and other parameters


Theory
--------------------

Important Definitions
........................

A breakpoint is defined by the reference template (i.e. chromosome), position (or range of positions) on the template, :term:`orientation`, and :term:`strand`.

One of the most confusing parts about working with :term:`contig` and paired-end reads is relating them to the breakpoint so that you can determine which types will support an event. For convenience We have shown the expected :term:`strand` and :term:`orientation` of both :term:`contig` and read-pair supporting evidence side-by-side for the major event types

.. image:: _static/svmerge_read_pairs_vs_contigs_evidence.svg

Gathering evidence from the bam file
......................................

we make two base assumptions in calculating the evidence window

1. the distribution of insert sizes approximately follows a normal distribution
2. the most common insert size is the unmutated 'normal' fragment

with the above assumptions we take the median insert size to be the expected normal

Given that we expect mutations and therefore abnormal insert sizes we use a modified method to calculate the **median standard deviation** (*s* in the equations below). We calculate the squared distance for each fragment away from the median and then take a fraction of this to be 'normal' variation. So the most abnormal portion is ignored, assuming it is supposed to be abnormal. This results in a calculation as follows, where the original set Y is the set of insert sizes from the bam file and f is the fraction of insert sizes assumed to be normal

.. math::

    l = |Y| \\
    m =
    \Biggl \lbrace
    {
    \frac{l}{2},\text{ if }
       {
         l \text{ is even}
        }
    \atop
    \frac{l - 1}{2} - 1, \text{ if } l \text{ is odd }
    }\\

    X = \left\{ x_i \mid x_i = (x_i - x_m)^2 \mid x_i \leq x_{i+1}\right\} \\

    s = \sqrt{\sum_{i=0}^{||l \cdot f||}{x_i}}

this gives us a measure of where we expect our normal read pairs insert sizes to fall. The :func:`~structural_variant.validate.Evidence.generate_window` function uses the above concepts. The user will define the :py:attr:`~structural_variant.validate.EvidenceSettings.median_insert_size` the :py:attr:`~structural_variant.validate.EvidenceSettings.tdev_isize`, and the :py:attr:`~structural_variant.validate.EvidenceSettings.stdev_count_abnormal` parameters defined in the :class:`~structural_variant.validate.EvidenceSettings` class.

If the library has a transcriptome protocol this becomes a bit more complicated and we must take into account the possible annotations when calculating the evidence window. see :func:`~structural_variant.validate.Evidence.generate_transcriptome_window` for more

.. image:: _static/svmerge_insert_size_distrb.svg

We use the abnormal insert-size read-pairs as flanking evidence. For example, if the event in question were a deletion we might expect to see larger insert-sizes


Classifying Events
.....................

the following decision tree is used in classifying events based on their breakpoints. Only valid combinations have been shown

.. image:: _static/svmerge_classification_tree.svg


Assembling Contigs
......................

During validation, for each breakpoint pair, we attempt to assemble a :term:`contig` to represent the sequence across the breakpoints. This is assembled from the :term:`split reads` and mates of :term:`half-mapped` reads that have been collected. The assembly uses a :term:`DeBruijn graph`.

Breakpoints can be called by multiple different :py:attr:`~structural_variant.validate.CALL_METHOD`.
