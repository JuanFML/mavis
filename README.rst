SVMerge User Manual
====================

About
--------------------

pipeline to merge and validate input from different structural variant callers into a single report

Getting started
--------------------

Installing the tool
....................

the tool has multiple dependencies from svn. These are listed in the install.sh bash script which also builds the autogenerated documentation. It should be run from the directory it is in

.. code-block:: bash

    cd /path/to/svmerge/dir
    pip install -r requirements.txt
    bash install.sh


Running Unit Tests
....................

to run the tests

.. code-block:: bash

    cd /path/to/svmerge/dir
    nosetests --with-coverage --cover-html --cover-html-dir=coverage --cover-package=structural_variant --cover-package=tools --cover-erase

Input Files
....................

The requirements are described in [JIRA](https://www.bcgsc.ca/jira/browse/APA-618) and are listed below.
These pertain to the input files from the various tools you want to merge

::

    | column name       | description                                                                       |
    |-------------------|-----------------------------------------------------------------------------------|
    | start_position    | range for the first breakpoint position                                           |
    | start_strand      | the reference strand aligned to                                                   |
    | start_orientation | the orientation (L or R) retained at the first breakpoint wrt the positive strand |
    | end_chromosome    |                                                                                   |
    | end_position      | range for the second breakpoint position                                          |
    | end_strand        | the reference strand aligned to                                                   |
    | end_orientation   | the orientation (L or R) retained at the second breakpoint wrt the positive strand|
    | protocol          | genome or transcriptome                                                           |
    | library           |                                                                                   |
    | tool_version      | tool name and tool version number joined with an underscore, no spaces            |
    | opposing_strand   | boolean value to describe if the breakpoints are on opposing strands              |
    | stranded          | boolean, if True then read1 in read pairs is assume to be the proper strand       |

Available Pre-formatting scripts
.................................

- Trans-ABySS
    - [convert_ta.py](https://svn.bcgsc.ca/svn/SVIA/sv_compile/tags/<version>/tools/convert_ta.py)
- DELLY
    - DUSTIN TO ADD
- MANTA
    - CALEB TO ADD

Building the documentation
...........................

if you don't use the install script there is also a wrapper script provided for generating the documentation

.. code-block:: bash

    cd /path/to/svmerge/dir/docs
    bash create.sh

this will generate html documentation that can be viewed in a browser by opening the index.html file

How it works
--------------------

The main pipeline consists of 3 scripts: sv_merge.py, sv_validate.py, and sv_annotate.py

sv_merge.py
....................

- takes in the calls from various tools and splits them by protocol and library
- clusters breakpoints by distance (user-configurable)

sv_validate.py
....................

- takes in the breakpoint calls
- sets a window around the breakpoints, based on user-configurable settings, for where to gather reads from the bam file. For genomic breakpoints this is a simple function of the read length, and other parameters


Theory
--------------------

Important Definitions
........................

A breakpoint is defined by the reference template (i.e. chromosome), position (or range of positions) on the template, :term:`orientation`, and :term:`strand`.

One of the most confusing parts about working with :term:`contig` and paired-end reads is relating them to the breakpoint so that you can determine which types will support an event. For convenience We have shown the expected :term:`strand` and :term:`orientation` of both :term:`contig` and read-pair supporting evidence side-by-side for the major event types

.. image:: _static/svmerge_read_pairs_vs_contigs_evidence.svg

Gathering evidence from the bam file
......................................

we make two base assumptions with regards to paired-end read data

1. the distribution of insert sizes approximately follows a normal distribution
2. the most common insert size is the unmutated 'normal' fragment

with the above assumptions we take the median insert size to be the expected normal

Given that we expect mutations and therefore abnormal insert sizes we use a modified method to calculate the **median standard deviation** (*s* in the equations below). We calculate the squared distance for each fragment away from the median and then take a fraction of this to be 'normal' variation. So the most abnormal portion is ignored, assuming it is supposed to be abnormal. This results in a calculation as follows, where the original set Y is the set of insert sizes from the bam file and f is the fraction of insert sizes assumed to be normal

.. math::

    l = |Y| \\
    y_m = \text{median value of Y}\\

    X = \left\{ x_i \mid x_i = (y_i - y_m)^2 \mid x_i \leq x_{i+1}\right\} \\

    s = \sqrt{\sum_{i=0}^{||l \cdot f||}{x_i}}

Using the above equation we can generate a modified version of the standard deviation (s above) as shown in the figure below (stdev). This gives us an idea of when to judge an insert size as abnormal and where we expect our normal read pairs insert sizes to fall.

.. figure::  _static/svmerge_insert_size_distrb.svg
    
    Distribution of insert sizes (absolute values) or proper read pairs. In the above image the standard deviation (stdev) was calculated with resepect to the median (383) using the fraction (f=0.99). Outlier insert sizes are shown in red.

We use this in two ways

1. to find flanking evidence supporting deletions and insertions
2. to estimate the window size for where we will need to read from the bam when looking for evidence for a given event
   
The :py:func:`~structural_variant.validate.Evidence.generate_window` function uses the above concepts. The user will define the :py:attr:`~structural_variant.validate.EvidenceSettings.median_insert_size` the :py:attr:`~structural_variant.validate.EvidenceSettings.tdev_isize`, and the :py:attr:`~structural_variant.validate.EvidenceSettings.stdev_count_abnormal` parameters defined in the :class:`~structural_variant.validate.EvidenceSettings` class.

If the library has a transcriptome protocol this becomes a bit more complicated and we must take into account the possible annotations when calculating the evidence window. see :py:func:`~structural_variant.validate.Evidence.generate_transcriptome_window` for more

Classifying Events
.....................

the following decision tree is used in classifying events based on their breakpoints. Only valid combinations have been shown

.. figure:: _static/svmerge_classification_tree.svg

    Classification Decision Tree. The above  diagram details the decsion logic for classifying events based on the orientation, strand and chromosomes or their respective breakpoints


Assembling Contigs
......................

During validation, for each breakpoint pair, we attempt to assemble a :term:`contig` to represent the sequence across the breakpoints. This is assembled from the :term:`split reads` and mates of :term:`half-mapped` reads that have been collected. The assembly uses a :term:`DeBruijn graph`.

Breakpoints can be called by multiple different :py:attr:`~structural_variant.validate.CALL_METHOD`.

Splicing Model
.....................

After the events have been called and an annotation has been attached, we often want to predict information about the putative fusion protein, which may be a product. In some cases, when a fusion transcript disrupts a splice-site, it is not clear what the processed fusion transcript may be. SVMerge will calculate all possibilities according to the following model.

.. figure:: _static/svmerge_splicing_model.svg
    
    Putative splicing scenarios. (A) a five-prime and the next three-prime splice sites are lost. (B) A five-prime splice site is lost. This brings about two splicing possibilities. Either the exon is skipped or the exon and proximal intron are retained. (C) A three-prime splice site is lost. (D) A three-prime splice site, and the next five-prime splice sites are lost.
